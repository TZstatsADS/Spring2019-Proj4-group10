A<-c(4,3,2,5,4,4,3,3,3,1)
B<-c(6,7,7,5,5,5,8,9,9,6)
C<-c(2,1,1,1,3,4,3,3,2,2)
X<-cbind(A,B,C)
var(X)
A<-c(4,3,2,5,4,4,3,3,3,1)
B<-c(6,7,7,5,5,5,8,9,9,6)
C<-c(2,1,1,1,3,4,3,3,2,2)
X<-cbind(A,B,C)
s<-cov(X)
x
s
log(s[1,1]*s[2,2]*s[3,3])*n
s<-cor(X)
n<-10
log(s[1,1]*s[2,2]*s[3,3])*n
s
r<-cor(X)
n<-10
log(det(r))*n
-log(det(r))*n
qchisq(0.95,3)#critical value
apply(X,2,mean)
xbar<-apply(X,2,mean)
x-xbar
X-xbar
X
x2m
xbar-mu0
mu0<-c(2,6,4)
#multivariate test
xbar<-apply(X,2,mean)
mu0<-c(2,6,4)
S<-var(X)/n
(n-3)/3*t(xbar-mu0)%*%solve(S)%*%(xbar-mu0)#test statistic
var(X)
var(X)/n
t(xbar-mu0)%*%solve(S)%*%(xbar-mu0)
(n-3)/3*t(xbar-mu0)%*%solve(S)%*%(xbar-mu0)#test statistic
qf(0.95,3,10-3)#critical value
(n-3)/3*t(xbar-mu0)%*%solve(S)%*%(xbar-mu0)#test statistic
solve(S)
xbar-mu0
solve(n*S)
S<-var(X)*(n-3)/n
solve(n*S)
S<-var(X)
solve(S)
S<-var(X)*(n-3)/n
solve(S)
S<-cov(X)*(n-3)/n
solve(S)
S<-cov(X)*(n-1)/n
solve(S)
S<-cov(X)/n
solve(S)
S<-cov(X)*n/(n-3)
solve(S)
S<-cov(X)*n/(n-2)
solve(S)
S<-cov(X)*n/(n-1)
solve(S)
X
S<-cov(X)
S<-cov(X)
solve(S)
S<-t(X)%*%X/n-t(xbar)%*%xbar
t(xbar)%*%xbar
S<-t(X)%*%X/n-(xbar)%*%t(xbar)
solve(S)
S<-var(X)*(n-3)/n
solve(S)
S<-var(X)*(n-2)/n
solve(S)
S<-var(X)*(n-1)/n
solve(S)
(n-3)/3*t(xbar-mu0)%*%solve(S)%*%(xbar-mu0)#test statistic
qf(0.95,3,10-3)#critical value
#univariate test
#u1
xbar[1]/sqrt(S[1,1])
#univariate test
#u1
(xbar[1]-2)/sqrt(S[1,1])
#univariate test
#u1
(xbar[1]-2)/sqrt(S[1,1]/n)
S<-var(X)*(n-1)/n
#univariate test
#u1
(xbar[1]-2)/sqrt(S[1,1]/n)
S<-var(X)
(n-3)/3*t(xbar-mu0)%*%solve(S)%*%(xbar-mu0)#test statistic
qf(0.95,3,10-3)#critical value
#univariate test
#u1
(xbar[1]-2)/sqrt(S[1,1]/n)
qt(0.975,9)
mu0
#univariate test
#u1
(xbar[1]-2)/sqrt(S[1,1]/n)#test statistics
qt(0.975,9)#critical value
#u2
(xbar[2]-6)/sqrt(S[2,2]/n)#test statistics
#u3
(xbar[3]-4)/sqrt(S[3,3]/n)#test statistics
#multivariate test
xbar<-apply(X,2,mean)
mu0<-c(2,6,4)
S<-var(X)
(n-3)/3*t(xbar-mu0)%*%solve(S)%*%(xbar-mu0)#test statistic
qf(0.95,3,10-3)#critical value
data(vocabulary)
data(vocabulary)
names(vocabulary)=c("grade8","grade9","grade10","grade11","mean")
res1=lm(grade11~grade8+grade9+grade10,data=vocabulary)
print(summary(res1))
data(wais)
x1 = wais[1:12,3:6]
x2 = wais[13:49,3:6]
a  = cov(x1)*11/12
b  = cov(x2)*36/37
c  = (12*a+37*b)/49
print(test<-49*log(det(c))-12*log(det(a))-37*log(det(b))) #test statistic
print(crit<-qchisq(0.95,10))  #critical value
wais
#Quantlet SMStestcovwais
data(wais)
x1 = wais[1:12,3:6]
x2 = wais[13:49,3:6]
a  = cov(x1)*11/12
b  = cov(x2)*36/37
c  = (12*a+37*b)/49
print(test<-49*log(det(c))-12*log(det(a))-37*log(det(b))) #test statistic
print(crit<-qchisq(0.95,10))  #critical value
#Quantlet SMSprofplasma
data(plasma)
plasma[,1]=factor(rep(c("Group 1","Group 2"),each=5))
plot(rbind(c(1,90),c(3,150)),type="n",ylab="Mean",xlab="Time",main="Profiles")
profiles=t(apply(plasma[,2:4],2,tapply,plasma$group,mean))
tmp=apply(profiles,2,lines)
text(x=2.2,y=145,"Group 1")
text(x=2.2,y=114,"Group 2")
cov.pool=(4/5)*(cov(plasma[1:5,2:4])+cov(plasma[6:10,2:4]))/2
diff=profiles[,1]-profiles[,2]
c=cbind(diag(rep(1,2)),rep(0,2))-cbind(rep(0,2),diag(rep(1,2)))
n1=5
n2=5
p=3
n=n1+n2
## are the profiles parallel?
test1=((n1*n2*(n1+n2-p))/((n^2)*(p-1)))*t(c%*%diff)%*%solve(c%*%cov.pool%*%t(c))%*%c%*%diff
test1
qf(0.95,2,7)
## test the equality of parallel profiles
ones=rep(1,3)
test2=((n1*n2*(n1+n2-2))/((n^2)))*(t(ones)%*%diff)^2/(t(ones)%*%cov.pool%*%ones)
test2
qf(0.95,1,8)
## test horizontality of parallel profiles
meanprf=apply(profiles,1,mean)
test3=((n1+n2-p)/(p-1))*t(c%*%meanprf)%*%solve(c%*%cov.pool%*%t(c))%*%c%*%meanprf
test3
qf(0.95,2,7)
#Quantlet SMSprofplasma
data(plasma)
plasma[,1]=factor(rep(c("Group 1","Group 2"),each=5))
#Quantlet SMSprofplasma
data(plasma)
plasma
plasma[,1]=factor(rep(c("Group 1","Group 2"),each=5))
plot(rbind(c(1,90),c(3,150)),type="n",ylab="Mean",xlab="Time",main="Profiles")
#Quantlet SMSprofplasma
data(plasma)
plasma[,1]=factor(rep(c("Group 1","Group 2"),each=5))
plot(rbind(c(1,90),c(3,150)),type="n",ylab="Mean",xlab="Time",main="Profiles")
profiles=t(apply(plasma[,2:4],2,tapply,plasma$group,mean))
tmp=apply(profiles,2,lines)
text(x=2.2,y=145,"Group 1")
text(x=2.2,y=114,"Group 2")
cov.pool=(4/5)*(cov(plasma[1:5,2:4])+cov(plasma[6:10,2:4]))/2
diff=profiles[,1]-profiles[,2]
c=cbind(diag(rep(1,2)),rep(0,2))-cbind(rep(0,2),diag(rep(1,2)))
n1=5
n2=5
p=3
n=n1+n2
## are the profiles parallel?
test1=((n1*n2*(n1+n2-p))/((n^2)*(p-1)))*t(c%*%diff)%*%solve(c%*%cov.pool%*%t(c))%*%c%*%diff
test1
qf(0.95,2,7)
## test the equality of parallel profiles
ones=rep(1,3)
test2=((n1*n2*(n1+n2-2))/((n^2)))*(t(ones)%*%diff)^2/(t(ones)%*%cov.pool%*%ones)
test2
qf(0.95,1,8)
## test horizontality of parallel profiles
meanprf=apply(profiles,1,mean)
test3=((n1+n2-p)/(p-1))*t(c%*%meanprf)%*%solve(c%*%cov.pool%*%t(c))%*%c%*%meanprf
test3
qf(0.95,2,7)
#Quantlet SMSprofplasma
data(plasma)
#plot graph profiles
plasma[,1]=factor(rep(c("Group 1","Group 2"),each=5))
plot(rbind(c(1,90),c(3,150)),type="n",ylab="Mean",xlab="Time",main="Profiles")
profiles=t(apply(plasma[,2:4],2,tapply,plasma$group,mean))
tmp=apply(profiles,2,lines)
text(x=2.2,y=145,"Group 1")
text(x=2.2,y=114,"Group 2")
#test
cov.pool=(4/5)*(cov(plasma[1:5,2:4])+cov(plasma[6:10,2:4]))/2
diff=profiles[,1]-profiles[,2]
c=cbind(diag(rep(1,2)),rep(0,2))-cbind(rep(0,2),diag(rep(1,2)))
n1=5
n2=5
p=3
n=n1+n2
## are the profiles parallel?
test1=((n1*n2*(n1+n2-p))/((n^2)*(p-1)))*t(c%*%diff)%*%solve(c%*%cov.pool%*%t(c))%*%c%*%diff
test1
qf(0.95,2,7)
## test the equality of parallel profiles
ones=rep(1,3)
test2=((n1*n2*(n1+n2-2))/((n^2)))*(t(ones)%*%diff)^2/(t(ones)%*%cov.pool%*%ones)
test2
qf(0.95,1,8)
## test horizontality of parallel profiles
meanprf=apply(profiles,1,mean)
test3=((n1+n2-p)/(p-1))*t(c%*%meanprf)%*%solve(c%*%cov.pool%*%t(c))%*%c%*%meanprf
test3
qf(0.95,2,7)
profiles
plot(rbind(c(1,90),c(3,150)),type="n",ylab="Mean",xlab="Time",main="Profiles")
profiles=t(apply(plasma[,2:4],2,tapply,plasma$group,mean))
tmp=apply(profiles,2,lines)
plasma[,1]=factor(rep(c("Group 1","Group 2"),each=5))
plot(rbind(c(1,90),c(3,150)),type="n",ylab="Mean",xlab="Time",main="Profiles")
profiles=t(apply(plasma[,2:4],2,tapply,plasma$group,mean))
tmp=apply(profiles,2,lines)
text(x=2.2,y=145,"Group 1")
text(x=2.2,y=114,"Group 2")
profiles
test1
qf(0.95,2,7)
## test the equality of parallel profiles
ones=rep(1,3)
test2=((n1*n2*(n1+n2-2))/((n^2)))*(t(ones)%*%diff)^2/(t(ones)%*%cov.pool%*%ones)
test2
qf(0.95,1,8)
## test horizontality of parallel profiles
meanprf=apply(profiles,1,mean)
test3=((n1+n2-p)/(p-1))*t(c%*%meanprf)%*%solve(c%*%cov.pool%*%t(c))%*%c%*%meanprf
test3
qf(0.95,2,7)
# convert factors to numeric
carc$R78 = as.numeric(as.character(carc$R78))
library(car)
library(glmnet)
library(glmnet)
data(carc)
# convert factors to numeric
carc$R78 = as.numeric(as.character(carc$R78))
library(car)
library(lasso2)
library(glmnet)
data(carc)
# convert factors to numeric
carc$R78 = as.numeric(as.character(carc$R78))
carc$R78
carc$R77 = as.numeric(as.character(carc$R77))
carc$C.EU= as.numeric(carc$C=="Europe")
carc$C   = as.numeric(carc$C=="US")
names(carc)[13]="C.US"
vif(lm(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc))
?l1ce
res     = l1ce(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc,bound=(1:40)/40)
# generalized cross-validation - simplification of usual leave-one-out CV
gcv.car = gcv(res)
opt.t   = gcv.car[which.min(gcv.car[,"gcv"]),1]
plres   = plot(res)
res
opt.t
## split graph.window
layout(matrix(c(1,2), 2, 1),heights=c(0.65,0.35))
## plot LASSO
matplot(plres$bound[,"rel.bound"],plres$mat[,-1],type="l",xlim=c(0,1.1),xlab="relative bound",ylab="coefficients",main="lasso for car data set")
library(car)
library(lasso2)
library(glmnet)
data(carc)
# convert factors to numeric
carc$R78 = as.numeric(as.character(carc$R78))
carc$R77 = as.numeric(as.character(carc$R77))
carc$C.EU= as.numeric(carc$C=="Europe")
carc$C   = as.numeric(carc$C=="US")
names(carc)[13]="C.US"
vif(lm(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc))
res     = l1ce(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc,bound=(1:40)/40)
# generalized cross-validation - simplification of usual leave-one-out CV
gcv.car = gcv(res)
opt.t   = gcv.car[which.min(gcv.car[,"gcv"]),1]
plres   = plot(res)
## split graph.window
layout(matrix(c(1,2), 2, 1),heights=c(0.65,0.35))
## plot LASSO
matplot(plres$bound[,"rel.bound"],plres$mat[,-1],type="l",xlim=c(0,1.1),xlab="relative bound",ylab="coefficients",main="lasso for car data set")
offs=rep("",13)
offs[c(1,3,6)]="    "
offs[6]="     "
text(cbind(1.03,coef(res[40])[-1]),paste(offs,labels(res)),cex=0.8,adj=0)
abline(v=opt.t,lty=2)
## plot GCV
plot(gcv.car[,"gcv"]~gcv.car[,1],xlim=c(0,1.1),type="l",ylab="GCV",xlab="relative bound",main="parameter selection")
library(car)
library(lasso2)
library(glmnet)
data(carc)
# convert factors to numeric
carc$R78 = as.numeric(as.character(carc$R78))
carc$R77 = as.numeric(as.character(carc$R77))
carc$C.EU= as.numeric(carc$C=="Europe")
carc$C   = as.numeric(carc$C=="US")
names(carc)[13]="C.US"
vif(lm(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc))
res     = l1ce(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc,bound=(1:40)/40)
# generalized cross-validation - simplification of usual leave-one-out CV
gcv.car = gcv(res)
opt.t   = gcv.car[which.min(gcv.car[,"gcv"]),1]
plres   = plot(res)
## split graph.window
layout(matrix(c(1,2), 2, 1),heights=c(0.65,0.35))
## plot LASSO
matplot(plres$bound[,"rel.bound"],plres$mat[,-1],type="l",xlim=c(0,1.1),xlab="relative bound",ylab="coefficients",main="lasso for car data set")
offs=rep("",13)
offs[c(1,3,6)]="    "
offs[6]="     "
text(cbind(1.03,coef(res[40])[-1]),paste(offs,labels(res)),cex=0.8,adj=0)
abline(v=opt.t,lty=2)
## plot GCV
plot(gcv.car[,"gcv"]~gcv.car[,1],xlim=c(0,1.1),type="l",ylab="GCV",xlab="relative bound",main="parameter selection")
library(car)
library(lasso2)
library(glmnet)
data(carc)
# convert factors to numeric
carc$R78 = as.numeric(as.character(carc$R78))
carc$R77 = as.numeric(as.character(carc$R77))
carc$C.EU= as.numeric(carc$C=="Europe")
carc$C   = as.numeric(carc$C=="US")
names(carc)[13]="C.US"
vif(lm(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc))
res     = l1ce(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc,bound=(1:40)/40)
# generalized cross-validation - simplification of usual leave-one-out CV
gcv.car = gcv(res)
opt.t   = gcv.car[which.min(gcv.car[,"gcv"]),1]
plres   = plot(res)
## split graph.window
#layout(matrix(c(1,2), 2, 1),heights=c(0.65,0.35))
## plot LASSO
matplot(plres$bound[,"rel.bound"],plres$mat[,-1],type="l",xlim=c(0,1.1),xlab="relative bound",ylab="coefficients",main="lasso for car data set")
offs=rep("",13)
offs[c(1,3,6)]="    "
offs[6]="     "
text(cbind(1.03,coef(res[40])[-1]),paste(offs,labels(res)),cex=0.8,adj=0)
abline(v=opt.t,lty=2)
## plot GCV
plot(gcv.car[,"gcv"]~gcv.car[,1],xlim=c(0,1.1),type="l",ylab="GCV",xlab="relative bound",main="parameter selection")
abline(v=opt.t,lty=2)
# coefficients
summary(l1ce(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc,bound=opt.t))$coefficients
library(car)
library(lasso2)
library(glmnet)
data(carc)
# convert factors to numeric
carc$R78 = as.numeric(as.character(carc$R78))
carc$R77 = as.numeric(as.character(carc$R77))
carc$C.EU= as.numeric(carc$C=="Europe")
carc$C   = as.numeric(carc$C=="US")
names(carc)[13]="C.US"
res     = l1ce(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc,bound=(1:40)/40)
# generalized cross-validation - simplification of usual leave-one-out CV
gcv.car = gcv(res)
opt.t   = gcv.car[which.min(gcv.car[,"gcv"]),1]
plres   = plot(res)
## split graph.window
#layout(matrix(c(1,2), 2, 1),heights=c(0.65,0.35))
## plot LASSO
matplot(plres$bound[,"rel.bound"],plres$mat[,-1],type="l",xlim=c(0,1.1),xlab="relative bound",ylab="coefficients",main="lasso for car data set")
offs=rep("",13)
offs[c(1,3,6)]="    "
offs[6]="     "
text(cbind(1.03,coef(res[40])[-1]),paste(offs,labels(res)),cex=0.8,adj=0)
abline(v=opt.t,lty=2)
## plot GCV
plot(gcv.car[,"gcv"]~gcv.car[,1],xlim=c(0,1.1),type="l",ylab="GCV",xlab="relative bound",main="parameter selection")
abline(v=opt.t,lty=2)
# coefficients
summary(l1ce(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc,bound=opt.t))$coefficients
carc
library(car)
library(lasso2)
library(glmnet)
data(carc)
# convert factors to numeric
carc$R78 = as.numeric(as.character(carc$R78))
carc$R77 = as.numeric(as.character(carc$R77))
carc$C.EU= as.numeric(carc$C=="Europe")
carc$C   = as.numeric(carc$C=="US")
names(carc)[13]="C.US"
res     = l1ce(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc,bound=(1:40)/40)
# generalized cross-validation - simplification of usual leave-one-out CV
gcv.car = gcv(res)
opt.t   = gcv.car[which.min(gcv.car[,"gcv"]),1]
plres   = plot(res)
## split graph.window
#layout(matrix(c(1,2), 2, 1),heights=c(0.65,0.35))
## plot LASSO
matplot(plres$bound[,"rel.bound"],plres$mat[,-1],type="l",xlim=c(0,1.1),xlab="relative bound",ylab="coefficients",main="lasso for car data set")
offs=rep("",13)
offs[c(1,3,6)]="    "
offs[6]="     "
text(cbind(1.03,coef(res[40])[-1]),paste(offs,labels(res)),cex=0.8,adj=0)
abline(v=opt.t,lty=2)
## plot GCV
plot(gcv.car[,"gcv"]~gcv.car[,1],xlim=c(0,1.1),type="l",ylab="GCV",xlab="relative bound",main="parameter selection")
abline(v=opt.t,lty=2)
# coefficients
summary(l1ce(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc,bound=opt.t))$coefficients
plres$mat
plres$bound
offs
matplot(plres$bound[,"rel.bound"],plres$mat[,-1],type="l",xlim=c(0,1.1),xlab="relative bound",ylab="coefficients",main="lasso for car data set")
offs=rep("",13)
offs[c(1,3,6)]="    "
offs[6]="     "
text(cbind(1.03,coef(res[40])[-1]),paste(offs,labels(res)),cex=0.8,adj=0)
res
library(car)
library(lasso2)
library(glmnet)
data(carc)
# convert factors to numeric
carc$R78 = as.numeric(as.character(carc$R78))
carc$R77 = as.numeric(as.character(carc$R77))
carc$C.EU= as.numeric(carc$C=="Europe")
carc$C   = as.numeric(carc$C=="US")
names(carc)[13]="C.US"
res     = l1ce(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc,bound=(1:40)/40)
# generalized cross-validation - simplification of usual leave-one-out CV
gcv.car = gcv(res)
opt.t   = gcv.car[which.min(gcv.car[,"gcv"]),1]
plres   = plot(res)
## split graph.window
#layout(matrix(c(1,2), 2, 1),heights=c(0.65,0.35))
## plot LASSO
matplot(plres$bound[,"rel.bound"],plres$mat[,-1],type="l",xlim=c(0,1.1),xlab="relative bound",ylab="coefficients",main="lasso for car data set")
offs=rep("",13)
offs[c(1,3,6)]="    "
offs[6]="     "
text(cbind(1.03,coef(res[40])[-1]),paste(offs,labels(res)),cex=0.8,adj=0)
abline(v=opt.t,lty=2)
## plot GCV
plot(gcv.car[,"gcv"]~gcv.car[,1],xlim=c(0,1.1),type="l",ylab="GCV",xlab="relative bound",main="parameter selection")
abline(v=opt.t,lty=2)
# coefficients
summary(l1ce(P~log(M)+R77+R78++H+R+Tr+W+L+T+log(D)+G+C.EU+C.US,data=carc,bound=opt.t))$coefficients
opt.t
library(e1071)
source('../lib/ifCleanToken.R')
load('../output/bigram.RData')
load('../output/datamatrix.RData')
load('../output/datamatrix.RData')
setwd("/Users/xiaoxi/Documents/GitHub/Spring2019-Proj4-group10/doc")
library(e1071)
source('../lib/ifCleanToken.R')
load('../output/bigram.RData')
load('../output/datamatrix.RData')
load('../output/datamatrix.RData')
train_mat<-as.data.frame(datamatrix[,c(-1,-2,-3,-4,-27)])
train_mat$ifwordcorrect<-factor(train_mat$ifwordcorrect)
#best model is with C=1, gamma=1
svm.best<-svm(ifwordcorrect~.,data=trainset,cost=1,gamma=1,scale=T,kernel="radial")
set.seed(1)
s<-sample(1:2,nrow(train_mat),prob=c(0.8,0.2),replace=T)
trainset<-train_mat[s==1,]
testset<-train_mat[s==2,]
#best model is with C=1, gamma=1
svm.best<-svm(ifwordcorrect~.,data=trainset,cost=1,gamma=1,scale=T,kernel="radial")
save(svm.best, file = "../output/svm.best.rda")
predvalue<-predict(svm.best, trainset[,-1])
save(predvalue, file = "../output/predvalue.rda")
load("../output/predvalue.rda")
mean(trainset[,-1]==predvalue)
predvalue
svm.best
svm.model
load("../output/svm.model.rda")
load("../output/svm.model.pred.rda")
svm.model
svm.pred
accuracy<- mean(svm.pred==train_mat$ifwordcorrect) #training accuracy
mean(trainset$ifcorrect==predvalue)
trainset$ifcorrect
mean(trainset$ifwordcorrect==predvalue)
#report training confusion matrix
confusionMatrix(data=predvalue,reference=trainset$ifwordcorrect)
#report training confusion matrix
library(caret)
confusionMatrix(data=predvalue,reference=trainset$ifwordcorrect)
