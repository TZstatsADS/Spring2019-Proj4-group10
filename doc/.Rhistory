newdatamatrix <- datamatrix
row.names(newdatamatrix) <- replace_after
newdatamatrix[,'j']
newdatamatrix[newdatamatrix[,'j'] == 1]
newdatamatrix[newdatamatrix[,'j'] == 2]
#split tesseract text and get row index
tesseract_split <- str_split(current_tesseract_txt, " ")
tes_split <- unlist(tesseract_split)
length(tes_split)
newdatamatrix[2000,]
newdatamatrix[,'j'] == 1
sum(newdatamatrix[,'j'] == 1)
newdatamatrix[newdatamatrix[,'j'] == 1,]
#read the text after correction
newdatamatrix[newdatamatrix[,'j'] == j,]$
#split tesseract text and get row index
tesseract_split <- str_split(current_tesseract_txt, " ")
tes_split <- unlist(tesseract_split)
#read the text after correction
newdatamatrix[newdatamatrix[,'j'] == j,]$
#split tesseract text and get row index
tesseract_split <- str_split(current_tesseract_txt, " ")
current_tesseract_txt
#split ground truth text and get row index
truth_split <- str_split(current_ground_truth_txt, " ")
#read the text after correction
newdatamatrix[newdatamatrix[,'j'] == j,]$
#split tesseract text and get row index
tesseract_split <- str_split(current_tesseract_txt, " ")
tesseract_split <- str_split(current_tesseract_txt, " ")
tes_split <- unlist(tesseract_split)
tes_split
length(tes_split)
nrow(newdatamatrix[newdatamatrix[,'j'] == j,])
new_correct_index <- function(num_of_file_name){
current_file_name <- sub(".txt","",file_name_vec[num_of_file_name])
## read the ground truth text
current_ground_truth_txt <- readLines(paste("../data/ground_truth/",current_file_name,".txt",sep=""), warn=FALSE)
#split ground truth text and get row index
truth_split <- str_split(current_ground_truth_txt, " ")
tru_split <- unlist(truth_split)
truth_lengthperrow <- sapply(truth_split, length)
truth_rowindex <- rep(1:length(current_ground_truth_txt), truth_lengthperrow)
#read the text after correction
tes_split <- newdatamatrix[newdatamatrix[,'j'] == j,]
###############
#get the correct position of corresponding word in ground truth text
#for each word, we find all it's matches in ground truth text, but there are some problems
#for example, 'and' may have several indexes in ground truth text. We want to find the correct one.
#for example, the third word only matches the last few words in the ground truth text, obviously it's not the right index.
###############
res = c()
pos = rep(list(0), length(tes_split))
truthpos <- c(0)
for (i in 1:length(tes_split)){
#if the word in OCR output appears in ground truth text
res[i] <- ifelse(tes_split[i] %in% tru_split,1,0)
#get all the matches for each appeared word
pos[[i]] <- if(res[i]==1) which(tru_split==tes_split[i]) else 0
}
tempindex <- cumsum(res)
#for each selected word in the loop, we have the index of it's previous selected word,
#if the previous selected word is not an appeared word, the index will be equal to the last appeared word.
#delete indexes which are smaller than the index of the previous selected word.
#and delete indexes which are greater than the smallest possible index of next two words
for (i in 1:length(tes_split)){
#get the index of next appeared word
nextnonzero1 <- min(which(tempindex == tempindex[i]+1))
#get the index of next second appeared word
nextnonzero2 <- min(which(tempindex == tempindex[i]+2))
a <- pos[[nextnonzero1]]
b <- pos[[nextnonzero2]]
#get a list of the right index of each word
#for those words which are not appeared in ground truth text, the index will equal to the previous appeared word.
#so the list include increasing numbers
truthpos[i+1] <- ifelse(sum((pos[[i]]>truthpos[i]) &
pos[[i]]<= min(a[a>truthpos[i]]) & pos[[i]]<= min(b[b>truthpos[i]])
)>0,
pos[[i]][min(which(pos[[i]]>truthpos[i]))],
truthpos[i])
}
truthpos <- truthpos[-1]
#let the indexes of words which are not appeared in ground truth text be 0
truthpos[c(0, diff(truthpos))==0] <- 0
#finally get the list with correct indexes.    1: correct, 0: wrong
ifwordcorrect <- rep(1,length(tes_split))
ifwordcorrect[truthpos==0] <- 0
#add row index in ground truth text
truth_row <- unlist(sapply(1:length(tes_split), function(x) ifelse(truthpos[x]==0,0,truth_rowindex[truthpos[x]])))
#create matrix
index <- 1:length(truth_row)
ifcorrectmatrix <- cbind(index, truthpos, ifwordcorrect)
rownames(ifcorrectmatrix) <- tes_split
total_correct_words <- sum(ttttt[,'ifwordcorrect']==1)
total_words <- nrow(ttttt)
return(list(ifcorrectmatrix=ifcorrectmatrix,
total_correct_words=total_correct_words,
total_words=total_words))
}
new_correct_index(1)
[newdatamatrix[,'j'] == 1]
newdatamatrix[,'j'] == 1]
newdatamatrix[,'j'] == 1
sum(newdatamatrix[,'j'] == 1)
new_correct_index <- function(num_of_file_name){
current_file_name <- sub(".txt","",file_name_vec[num_of_file_name])
## read the ground truth text
current_ground_truth_txt <- readLines(paste("../data/ground_truth/",current_file_name,".txt",sep=""), warn=FALSE)
#split ground truth text and get row index
truth_split <- str_split(current_ground_truth_txt, " ")
tru_split <- unlist(truth_split)
truth_lengthperrow <- sapply(truth_split, length)
truth_rowindex <- rep(1:length(current_ground_truth_txt), truth_lengthperrow)
#read the text after correction
tes_split <- replace_after[newdatamatrix[,'j'] == 1]
###############
#get the correct position of corresponding word in ground truth text
#for each word, we find all it's matches in ground truth text, but there are some problems
#for example, 'and' may have several indexes in ground truth text. We want to find the correct one.
#for example, the third word only matches the last few words in the ground truth text, obviously it's not the right index.
###############
res = c()
pos = rep(list(0), length(tes_split))
truthpos <- c(0)
for (i in 1:length(tes_split)){
#if the word in OCR output appears in ground truth text
res[i] <- ifelse(tes_split[i] %in% tru_split,1,0)
#get all the matches for each appeared word
pos[[i]] <- if(res[i]==1) which(tru_split==tes_split[i]) else 0
}
tempindex <- cumsum(res)
#for each selected word in the loop, we have the index of it's previous selected word,
#if the previous selected word is not an appeared word, the index will be equal to the last appeared word.
#delete indexes which are smaller than the index of the previous selected word.
#and delete indexes which are greater than the smallest possible index of next two words
for (i in 1:length(tes_split)){
#get the index of next appeared word
nextnonzero1 <- min(which(tempindex == tempindex[i]+1))
#get the index of next second appeared word
nextnonzero2 <- min(which(tempindex == tempindex[i]+2))
a <- pos[[nextnonzero1]]
b <- pos[[nextnonzero2]]
#get a list of the right index of each word
#for those words which are not appeared in ground truth text, the index will equal to the previous appeared word.
#so the list include increasing numbers
truthpos[i+1] <- ifelse(sum((pos[[i]]>truthpos[i]) &
pos[[i]]<= min(a[a>truthpos[i]]) & pos[[i]]<= min(b[b>truthpos[i]])
)>0,
pos[[i]][min(which(pos[[i]]>truthpos[i]))],
truthpos[i])
}
truthpos <- truthpos[-1]
#let the indexes of words which are not appeared in ground truth text be 0
truthpos[c(0, diff(truthpos))==0] <- 0
#finally get the list with correct indexes.    1: correct, 0: wrong
ifwordcorrect <- rep(1,length(tes_split))
ifwordcorrect[truthpos==0] <- 0
#add row index in ground truth text
truth_row <- unlist(sapply(1:length(tes_split), function(x) ifelse(truthpos[x]==0,0,truth_rowindex[truthpos[x]])))
#create matrix
index <- 1:length(truth_row)
ifcorrectmatrix <- cbind(index, truthpos, ifwordcorrect)
rownames(ifcorrectmatrix) <- tes_split
total_correct_words <- sum(ifcorrectmatrix[,'ifwordcorrect']==1)
total_words <- nrow(ifcorrectmatrix)
return(list(ifcorrectmatrix=ifcorrectmatrix,
total_correct_words=total_correct_words,
total_words=total_words,))
}
new_correct_index(2)
new_correct_index <- function(num_of_file_name){
current_file_name <- sub(".txt","",file_name_vec[num_of_file_name])
## read the ground truth text
current_ground_truth_txt <- readLines(paste("../data/ground_truth/",current_file_name,".txt",sep=""), warn=FALSE)
#split ground truth text and get row index
truth_split <- str_split(current_ground_truth_txt, " ")
tru_split <- unlist(truth_split)
truth_lengthperrow <- sapply(truth_split, length)
truth_rowindex <- rep(1:length(current_ground_truth_txt), truth_lengthperrow)
#read the text after correction
tes_split <- replace_after[newdatamatrix[,'j'] == 1]
###############
#get the correct position of corresponding word in ground truth text
#for each word, we find all it's matches in ground truth text, but there are some problems
#for example, 'and' may have several indexes in ground truth text. We want to find the correct one.
#for example, the third word only matches the last few words in the ground truth text, obviously it's not the right index.
###############
res = c()
pos = rep(list(0), length(tes_split))
truthpos <- c(0)
for (i in 1:length(tes_split)){
#if the word in OCR output appears in ground truth text
res[i] <- ifelse(tes_split[i] %in% tru_split,1,0)
#get all the matches for each appeared word
pos[[i]] <- if(res[i]==1) which(tru_split==tes_split[i]) else 0
}
tempindex <- cumsum(res)
#for each selected word in the loop, we have the index of it's previous selected word,
#if the previous selected word is not an appeared word, the index will be equal to the last appeared word.
#delete indexes which are smaller than the index of the previous selected word.
#and delete indexes which are greater than the smallest possible index of next two words
for (i in 1:length(tes_split)){
#get the index of next appeared word
nextnonzero1 <- min(which(tempindex == tempindex[i]+1))
#get the index of next second appeared word
nextnonzero2 <- min(which(tempindex == tempindex[i]+2))
a <- pos[[nextnonzero1]]
b <- pos[[nextnonzero2]]
#get a list of the right index of each word
#for those words which are not appeared in ground truth text, the index will equal to the previous appeared word.
#so the list include increasing numbers
truthpos[i+1] <- ifelse(sum((pos[[i]]>truthpos[i]) &
pos[[i]]<= min(a[a>truthpos[i]]) & pos[[i]]<= min(b[b>truthpos[i]])
)>0,
pos[[i]][min(which(pos[[i]]>truthpos[i]))],
truthpos[i])
}
truthpos <- truthpos[-1]
#let the indexes of words which are not appeared in ground truth text be 0
truthpos[c(0, diff(truthpos))==0] <- 0
#finally get the list with correct indexes.    1: correct, 0: wrong
ifwordcorrect <- rep(1,length(tes_split))
ifwordcorrect[truthpos==0] <- 0
#add row index in ground truth text
truth_row <- unlist(sapply(1:length(tes_split), function(x) ifelse(truthpos[x]==0,0,truth_rowindex[truthpos[x]])))
#create matrix
index <- 1:length(truth_row)
ifcorrectmatrix <- cbind(index, truthpos, ifwordcorrect)
rownames(ifcorrectmatrix) <- tes_split
total_correct_words <- sum(ifcorrectmatrix[,'ifwordcorrect']==1)
total_words <- nrow(ifcorrectmatrix)
return(list(ifcorrectmatrix=ifcorrectmatrix,
total_correct_words=total_correct_words,
total_words=total_words))
}
new_correct_index(2)
new_correct_index <- function(num_of_file_name){
current_file_name <- sub(".txt","",file_name_vec[num_of_file_name])
## read the ground truth text
current_ground_truth_txt <- readLines(paste("../data/ground_truth/",current_file_name,".txt",sep=""), warn=FALSE)
#split ground truth text and get row index
truth_split <- str_split(current_ground_truth_txt, " ")
tru_split <- unlist(truth_split)
truth_lengthperrow <- sapply(truth_split, length)
truth_rowindex <- rep(1:length(current_ground_truth_txt), truth_lengthperrow)
#read the text after correction
tes_split <- replace_after[newdatamatrix[,'j'] == num_of_file_name]
###############
#get the correct position of corresponding word in ground truth text
#for each word, we find all it's matches in ground truth text, but there are some problems
#for example, 'and' may have several indexes in ground truth text. We want to find the correct one.
#for example, the third word only matches the last few words in the ground truth text, obviously it's not the right index.
###############
res = c()
pos = rep(list(0), length(tes_split))
truthpos <- c(0)
for (i in 1:length(tes_split)){
#if the word in OCR output appears in ground truth text
res[i] <- ifelse(tes_split[i] %in% tru_split,1,0)
#get all the matches for each appeared word
pos[[i]] <- if(res[i]==1) which(tru_split==tes_split[i]) else 0
}
tempindex <- cumsum(res)
#for each selected word in the loop, we have the index of it's previous selected word,
#if the previous selected word is not an appeared word, the index will be equal to the last appeared word.
#delete indexes which are smaller than the index of the previous selected word.
#and delete indexes which are greater than the smallest possible index of next two words
for (i in 1:length(tes_split)){
#get the index of next appeared word
nextnonzero1 <- min(which(tempindex == tempindex[i]+1))
#get the index of next second appeared word
nextnonzero2 <- min(which(tempindex == tempindex[i]+2))
a <- pos[[nextnonzero1]]
b <- pos[[nextnonzero2]]
#get a list of the right index of each word
#for those words which are not appeared in ground truth text, the index will equal to the previous appeared word.
#so the list include increasing numbers
truthpos[i+1] <- ifelse(sum((pos[[i]]>truthpos[i]) &
pos[[i]]<= min(a[a>truthpos[i]]) & pos[[i]]<= min(b[b>truthpos[i]])
)>0,
pos[[i]][min(which(pos[[i]]>truthpos[i]))],
truthpos[i])
}
truthpos <- truthpos[-1]
#let the indexes of words which are not appeared in ground truth text be 0
truthpos[c(0, diff(truthpos))==0] <- 0
#finally get the list with correct indexes.    1: correct, 0: wrong
ifwordcorrect <- rep(1,length(tes_split))
ifwordcorrect[truthpos==0] <- 0
#add row index in ground truth text
truth_row <- unlist(sapply(1:length(tes_split), function(x) ifelse(truthpos[x]==0,0,truth_rowindex[truthpos[x]])))
#create matrix
index <- 1:length(truth_row)
ifcorrectmatrix <- cbind(index, truthpos, ifwordcorrect)
rownames(ifcorrectmatrix) <- tes_split
total_correct_words <- sum(ifcorrectmatrix[,'ifwordcorrect']==1)
total_words <- nrow(ifcorrectmatrix)
return(list(ifcorrectmatrix=ifcorrectmatrix,
total_correct_words=total_correct_words,
total_words=total_words))
}
new_correct_index(1)
new_correct_index(2)
lapply(1:100, function(x) new_correct_index(x)$total_correct_words)
lapply(1:3, function(x) new_correct_index(x)$total_correct_words)
lapply(1:3, function(x) new_correct_index(x)$total_words)
new_correct_index(2)
warnings()
a = lapply(1:3, function(x) new_correct_index(x)$total_correct_words)
b = lapply(1:3, function(x) new_correct_index(x)$total_words)
a
b
a/b
sum(a)
sum(unlist(a))
sum(unlist(b))
sum(unlist(a))/sum(unlist(b))
a = lapply(1:20, function(x) new_correct_index(x)$total_correct_words)
b = lapply(1:20, function(x) new_correct_index(x)$total_words)
sum(unlist(a))/sum(unlist(b))
if (!require("devtools")) install.packages("devtools")
if (!require("caret")) install.packages("devtools")
if (!require("pacman")) {
## devtools is required
library(devtools)
install_github("trinker/pacman")
}
library(e1071)
pacman::p_load(knitr, readr, stringr, tesseract, vecsets)
source('../lib/ifCleanToken.R')
source('../lib/correct_index_func.R')
load('../output/bigram.RData')
file_name_vec <- list.files("../data/ground_truth") #100 files in total
length(ground_truth_vec)
length(replace_before)
head(dete_error)
for(i in c(1:length(file_name_vec))){
inputtxt <- readLines(paste("../data/ground_truth/",file_name_vec[i],sep=""), warn=FALSE, encoding = 'UTF-8')
truth <- c(truth, inputtxt)
}
#head(truth,15)
ground_truth_vec <- unlist(strsplit(tolower(truth), " "))
nrow(ground_truth_vec)
library(tidyr)
truth <- c()
for(i in c(1:length(file_name_vec))){
inputtxt <- readLines(paste("../data/ground_truth/",file_name_vec[i],sep=""), warn=FALSE, encoding = 'UTF-8')
truth <- c(truth, inputtxt)
}
#head(truth,15)
ground_truth_vec <- unlist(strsplit(tolower(truth), " "))
load("../output/svm.model.pred.rda")
nrow(ground_truth_vec)
truth
#head(truth,15)
ground_truth_vec <- unlist(strsplit(tolower(truth), " "))
ground_truth_vec
length(ground_truth_vec)
#length(ground_truth_vec)
#tesseract_vec with detected error
load("../output/svm.model.pred.rda")
View(dete_error)
nrow(datamatrix)/legnth(truth)
truth
ground_truth_vec
length(ground_truth_vec)
nrow(datamatrix)/length(ground_truth_vec)
load("../output/svm.model.pred.rda")
svm.pred
length(svm.pred)
nrow(datamatrix)
head(datamatrix)
sum(ifwordcorrect[,'ifwordcorrect'])
sum(datamatrix[,'ifwordcorrect'])
sum(datamatrix[,'ifwordcorrect'])/length(ground_truth_vec)
sum(datamatrix[,'ifwordcorrect'])/nrow(datamatrix)
sum(datamatrix[,'ifwordcorrect'])/length(ground_truth_vec)
a = lapply(1:10, function(x) new_correct_index(x)$total_correct_words)
a
b = lapply(1:10, function(x) new_correct_index(x)$total_words)
sum(unlist(a))/sum(unlist(b))
library(tidyr)
truth <- c()
for(i in c(1:length(file_name_vec))){
inputtxt <- readLines(paste("../data/ground_truth/",file_name_vec[i],sep=""), warn=FALSE, encoding = 'UTF-8')
truth <- c(truth, inputtxt)
}
#head(truth,15)
ground_truth_vec <- unlist(strsplit(tolower(truth), " "))
load("../output/svm.model.pred.rda")
tesseract_vec <-rownames(datamatrix)#298728
tesseract_if_clean<-svm.pred#298728
tesseract_if_error<-ifelse(tesseract_if_clean==1,F,T)
#combine the true words and the corrected words
tesseract_vec_clean <- c(tesseract_vec[!tesseract_if_error],tesseract_correct_vec)
## Here, we compare the lower case version of the tokens
old_intersect_vec <- vecsets::vintersect(tolower(ground_truth_vec), tolower(tesseract_vec))
head(datamatrix,20)
rownames(datamatrix)
replace_before <- tolower(rownames(datamatrix))
replace_after <- unlist(lapply(replace_before, function(x) replace_func(x)))
correct_after_correction = lapply(1:100, function(x) new_correct_index(x)$total_correct_words)
correct_after_correction
total_after_correction = lapply(1:100, function(x) new_correct_index(x)$total_words)
total_after_correction
correct_after_correction
total_after_correction
sum(unlist(correct_after_correction))
sum(unlist(total_after_correction))
length(ground_truth_vec)
correct_after_correction = lapply(1:100, function(x) new_correct_index(x)$total_correct_words)
correct_after_correction
datamatrix[,'j'==97]
head(datamatrix[,'j']==97)
datamatrix[datamatrix[,'j']==97,]
demo = datamatrix[datamatrix[,'j']==97,]
sum(demo[,'ifwordcorrect'])/nrow(demo)
correct_after_correction
sum(unlist(correct_after_correction))/sum(unlist(total_after_correction))
sum(unlist(correct_after_correction))/length(ground_truth_vec)
correct_after_correction
new_correct_index(1)
num_of_file_name=1
current_file_name <- sub(".txt","",file_name_vec[num_of_file_name])
## read the ground truth text
current_ground_truth_txt <- readLines(paste("../data/ground_truth/",current_file_name,".txt",sep=""), warn=FALSE)
#split ground truth text and get row index
truth_split <- tolower(str_split(current_ground_truth_txt, " "))
truth_split
#split ground truth text and get row index
truth_split <- str_split(current_ground_truth_txt, " ")
truth_split
tru_split <- unlist(truth_split)
tru_split
tru_split <- tolower(unlist(truth_split))
tru_split
new_correct_index <- function(num_of_file_name){
current_file_name <- sub(".txt","",file_name_vec[num_of_file_name])
## read the ground truth text
current_ground_truth_txt <- readLines(paste("../data/ground_truth/",current_file_name,".txt",sep=""), warn=FALSE)
#split ground truth text and get row index
truth_split <- str_split(current_ground_truth_txt, " ")
tru_split <- tolower(unlist(truth_split))
truth_lengthperrow <- sapply(truth_split, length)
truth_rowindex <- rep(1:length(current_ground_truth_txt), truth_lengthperrow)
#read the text after correction
tes_split <- replace_after[newdatamatrix[,'j'] == num_of_file_name]
###############
#get the correct position of corresponding word in ground truth text
#for each word, we find all it's matches in ground truth text, but there are some problems
#for example, 'and' may have several indexes in ground truth text. We want to find the correct one.
#for example, the third word only matches the last few words in the ground truth text, obviously it's not the right index.
###############
res = c()
pos = rep(list(0), length(tes_split))
truthpos <- c(0)
for (i in 1:length(tes_split)){
#if the word in OCR output appears in ground truth text
res[i] <- ifelse(tes_split[i] %in% tru_split,1,0)
#get all the matches for each appeared word
pos[[i]] <- if(res[i]==1) which(tru_split==tes_split[i]) else 0
}
tempindex <- cumsum(res)
#for each selected word in the loop, we have the index of it's previous selected word,
#if the previous selected word is not an appeared word, the index will be equal to the last appeared word.
#delete indexes which are smaller than the index of the previous selected word.
#and delete indexes which are greater than the smallest possible index of next two words
for (i in 1:length(tes_split)){
#get the index of next appeared word
nextnonzero1 <- min(which(tempindex == tempindex[i]+1))
#get the index of next second appeared word
nextnonzero2 <- min(which(tempindex == tempindex[i]+2))
a <- pos[[nextnonzero1]]
b <- pos[[nextnonzero2]]
#get a list of the right index of each word
#for those words which are not appeared in ground truth text, the index will equal to the previous appeared word.
#so the list include increasing numbers
truthpos[i+1] <- ifelse(sum((pos[[i]]>truthpos[i]) &
pos[[i]]<= min(a[a>truthpos[i]]) & pos[[i]]<= min(b[b>truthpos[i]])
)>0,
pos[[i]][min(which(pos[[i]]>truthpos[i]))],
truthpos[i])
}
truthpos <- truthpos[-1]
#let the indexes of words which are not appeared in ground truth text be 0
truthpos[c(0, diff(truthpos))==0] <- 0
#finally get the list with correct indexes.    1: correct, 0: wrong
ifwordcorrect <- rep(1,length(tes_split))
ifwordcorrect[truthpos==0] <- 0
#add row index in ground truth text
truth_row <- unlist(sapply(1:length(tes_split), function(x) ifelse(truthpos[x]==0,0,truth_rowindex[truthpos[x]])))
#create matrix
index <- 1:length(truth_row)
ifcorrectmatrix <- cbind(index, truthpos, ifwordcorrect)
rownames(ifcorrectmatrix) <- tes_split
total_correct_words <- sum(ifcorrectmatrix[,'ifwordcorrect']==1)
total_words <- nrow(ifcorrectmatrix)
return(list(total_correct_words=total_correct_words,
total_words=total_words))
}
correct_after_correction = lapply(1:100, function(x) new_correct_index(x)$total_correct_words)
correct_after_correction
total_after_correction = lapply(1:100, function(x) new_correct_index(x)$total_words)
OCR_performance_table["word_wise_recall","Tesseract_with_postprocessing"] <- sum(unlist(correct_after_correction))/sum(unlist(total_after_correction))
OCR_performance_table["word_wise_precision","Tesseract_with_postprocessing"] <- sum(unlist(correct_after_correction))/length(ground_truth_vec)
OCR_performance_table["word_wise_recall","Tesseract"] <- sum(datamatrix[,'ifwordcorrect'])/nrow(datamatrix)
OCR_performance_table["word_wise_precision","Tesseract"] <- sum(datamatrix[,'ifwordcorrect'])/length(ground_truth_vec)
OCR_performance_table["word_wise_recall","Tesseract_with_postprocessing"] <- sum(unlist(correct_after_correction))/sum(unlist(total_after_correction))
OCR_performance_table["word_wise_precision","Tesseract_with_postprocessing"] <- sum(unlist(correct_after_correction))/length(ground_truth_vec)
OCR_performance_table
correct_after_correction = lapply(1:100, function(x) new_correct_index(x)$total_correct_words)
correct_after_correction
